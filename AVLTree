import static java.lang.Math.max;

public class AVLTree extends Tree{
    private int count;

    //Construtor:
    public AVLTree(Node root) {
        super(root);
        this.count = 0;
    }

    //Função de adicionar nó
    @Override
    public Node addAVL(int key, int height, Node atual) {
        if (atual == null) {
            return new Node(key, height);
        }
        if (key < atual.key){
            atual.left = addAVL(key, height, atual.left);
        } else if (key > atual.key) {
            atual.right = addAVL(key, height, atual.right);
        }else {
            return atual;
        }
        atual.height = 1 + max(height(atual.left), height(atual.right));
        return checkBalance(atual);
    }

    //Função de altura da árvore
    @Override
    public int height(Node node) {
        if (node == null) {
            return 0;
        } else {
            int LChildHeight = height(node.left);
            int RChildHeight = height(node.right);
            node.height = max(LChildHeight, RChildHeight)+1;
            return node.height;
        }
    }

    //Função de equilíbrio
    @Override
    public Node checkBalance(Node node) {
        //direita ou esquerda-direita, verificar se valor é < ou > que o pai
        //esquerda ou direita-esquerda, verificar se valor é < ou > que o pai

        int fatorEqui = height(node.left) - height(node.right);

        if (fatorEqui > 1) {
            if (height(node.right.right) > height(node.right.left)) {
                node = rotateL(node);
            } else {
                node.right = rotateR(node.right);
                node = rotateL(node);
            }
        } else if (fatorEqui < -1) {
            if (height(node.left.left) > height(node.left.right)) {
                node = rotateR(node);
            } else {
                node.left = rotateL(node.left);
                node = rotateR(node);
            }

        }

        /*
        if (fatorEqui > 1 && node.key < node.left.key){
            return rotateR(node);

        } else if (fatorEqui < -1 && node.key > node.right.key) {
            return rotateL(node);

        } else if (fatorEqui > 1 && node.key > node.left.key) {
            node.left = rotateL(node.left);
            return rotateR(node);
        } else if (fatorEqui < -1 && node.key < node.right.key) {
            node.right = rotateR(node.right);
            return rotateL(node);
        }

         */
        return node;
    }

    //Função de rotação de direita
    public Node rotateR(Node node) {
        if (node == null || node.left == null) {
            return node;
        }

        Node LChild = node.left;
        Node x = LChild.right;
        LChild.right = node;
        node.left = x;

        //atualização das alturas
        node.height = 1 + max(height(node.left), height(node.right));
        LChild.height = 1 + max(height(LChild.left), height(LChild.right));

        count++;
        return LChild;
    }

    //Função de rotação de esquerda
    public Node rotateL(Node node){
        if (node == null || node.right == null) {
            return node;
        }
        Node RChild = node.right;
        Node x = RChild.left;

        RChild.left = node;
        node.right = x;

        //atualização das alturas
        node.height = 1 + max(height(node.left), height(node.right));
        RChild.height = 1 + max(height(RChild.left), height(RChild.right));

        count++;
        return RChild;
    }

    public int getCount() {
        return count;
    }

    @Override
    public Node find(Node atual, int key) {
        while (atual != null) {
            if (key == atual.key) {
                return atual;
            } else if (key < atual.key) {
                atual = atual.left;
            } else {
                atual = atual.right;
            }
        }
        return null;
    }

    //Funções não usadas por esta classe:
    @Override
    public void addBT(int key, Node atual) {}
    @Override
    public Node addBTS(int key, Node atual) {
        return null;
    }

}
